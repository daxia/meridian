# TypeScript Cloudflare Workers 类型兼容性与错误处理修复经验

## 问题描述

在 Cloudflare Workers 后端开发中，升级依赖或严格类型检查模式下，出现了以下几类 TypeScript 编译错误：

1.  **Queue Handler 类型不匹配**:
    ```typescript
    Type '(batch: MessageBatch<ProcessArticlesParams>, ...)' is not assignable to type 'ExportedHandlerQueueHandler<Env, unknown>'.
    Types of parameters 'batch' and 'batch' are incompatible.
    Type 'MessageBatch<unknown>' is not assignable to type 'MessageBatch<ProcessArticlesParams>'.
    ```

2.  **Scheduled Handler 类型不匹配**:
    ```typescript
    Type '(event: ScheduledEvent, ...)' is not assignable to type 'ExportedHandlerScheduledHandler<Env>'.
    Type 'ScheduledController' is missing the following properties from type 'ScheduledEvent': waitUntil, type, eventPhase, composed, ...
    ```

3.  **Catch Block 类型安全**:
    ```typescript
    Object literal may only specify known properties, and 'error' does not exist in type 'Error'.
    Type 'unknown' is not assignable to type 'Error'.
    ```

## 根因分析

1.  **Cloudflare Types 定义变更**: `@cloudflare/workers-types` 的新版本中，`ScheduledEvent` 已被 `ScheduledController` 替代或并在某些上下文中行为改变。`ExportedHandler` 接口定义的泛型参数默认是 `unknown`，导致具体类型实现（如 `ProcessArticlesParams`）无法直接逆变赋值。
2.  **TypeScript 4.0+ 异常类型**: 在较新的 TS 版本和严格配置中，`catch (e)` 中的 `e` 默认为 `unknown` 而非 `any`。这要求必须显式进行类型守卫（Type Guard）。
3.  **Logger 接口限制**: 项目使用的 `Logger` 库在 `error` 方法中对参数位置有严格定义，签名为 `error(message, error?, context?)`。如果想传递 context 但没有 Error 对象，必须显式传递 `undefined`。

## 解决方案

### 1. Queue Handler 泛型宽容处理

将入口函数的参数类型放宽为 `any`，然后在函数体内进行类型断言。这是处理框架通用接口与具体业务类型不匹配的常用模式。

```typescript
// Before
async queue(batch: MessageBatch<ProcessArticlesParams>, ...) { ... }

// After
async queue(batch: MessageBatch<any>, env: Env, ctx: ExecutionContext): Promise<void> {
    // 内部处理时再断言
    const { ingested_item_ids } = message.body as ProcessArticlesParams;
    ...
}
```

### 2. Scheduled Handler 类型更新

使用 `ScheduledController` 替代过时的 `ScheduledEvent`。

```typescript
// Before
async scheduled(event: ScheduledEvent, ...) { ... }

// After
async scheduled(event: ScheduledController, ...) { ... }
```

### 3. 异常捕获与日志记录规范化

在 catch 块中显式处理 `unknown` 类型，并避免在日志 metadata 中使用保留字段名或不存在的字段。
同时，注意 `Logger.error` 的签名是 `(message: string, error?: Error, context?: Record<string, unknown>)`。如果只需要传递上下文而没有 Error 对象（或者已经将 Error 转化为字符串放入上下文中），必须显式将第二个参数设为 `undefined`。

```typescript
// Before
} catch (e: unknown) {
    // 错误：Logger 会尝试将对象字面量解析为 Error 类型，导致类型不匹配
    logger.error('...', { text, error: e.message }); 
}

// After
} catch (e: unknown) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    
    // 显式传递 undefined 作为第二个参数
    logger.error('...', undefined, { 
        text_snippet: text.substring(0, 200), 
        error_message: errorMessage 
    });
}
```

### 4. Result 类型解包

对于 `Result` 类型（如 `neverthrow` 或自定义 Result），必须显式断言 `error` 类型，因为泛型可能推断为 `unknown`。

```typescript
if (result.isErr()) {
    const error = result.error as Error; // 显式断言
    throw new Error(`Clustering failed: ${error.message}`);
}
```

## 经验总结

1.  **优先遵循框架类型**: 当业务类型与框架接口冲突时，在边界处（Handler 入口）使用 `any` 或 `unknown` 接收，随即在内部进行 validate/assert，比强行修改函数签名更安全。
2.  **防御性日志记录**: 记录错误日志时，永远不要假设 `catch` 到的是一个标准的 `Error` 对象。始终进行 `instanceof` 检查或 `String()` 转换。
3.  **日志字段规范**: 避免在日志 metadata 中直接传递复杂的对象（如完整的 `Error` 对象），尽量提取关键字段（message, stack, code）并使用明确的键名（如 `error_message`）。
