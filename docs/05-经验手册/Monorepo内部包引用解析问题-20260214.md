# Monorepo 内部包引用解析问题 - 20260214

## 问题描述

在 Monorepo 架构中，当 Backend (Cloudflare Workers) 和 Frontend (Nuxt) 引用本地 workspace 包（如 `@meridian/logger`）时，构建工具报错无法解析模块。

### 报错信息

**Backend (Wrangler):**
```
X [ERROR] Could not resolve "@meridian/logger"
You can mark the path "@meridian/logger" as external to exclude it from the bundle...
```

**Frontend (Vite/Nuxt):**
```
[vite-node] [ERR_LOAD_URL] @meridian/logger from "src/plugins/logger.ts"
```

## 根因分析

1.  **Node 模块解析机制**: 默认情况下，构建工具会查找 `node_modules/@meridian/logger`。
2.  **符号链接与未编译源码**: 虽然 `pnpm` 创建了符号链接，但链接指向的是包含 `.ts` 源码的包。
3.  **构建工具限制**: 
    *   Wrangler 和 Vite 默认不处理 `node_modules` 内的 `.ts` 文件转译。
    *   即使配置了 `tsconfig.json` 的 `paths`，这仅对 IDE 和 `tsc` 有效，对打包工具（如 esbuild, rollup）不一定生效，除非显式配置别名。

## 解决方案

为了兼顾开发体验（热更新）和构建稳定性，我们在构建配置层面强制指定源码路径别名，绕过 `dist` 构建产物（如果存在）。

### 1. Backend (Wrangler)

在 `wrangler.jsonc` 中添加 `alias` 配置，明确指向 TypeScript 源码入口：

```jsonc
{
  "alias": {
    "@meridian/logger": "../../packages/logger/src/index.ts"
  }
  // ...
}
```

### 2. Frontend (Nuxt)

在 `nuxt.config.ts` 中添加 `alias` 配置：

```typescript
export default defineNuxtConfig({
  alias: {
    '@meridian/logger': '../../packages/logger/src/index.ts',
  },
  // ...
});
```

### 3. IDE 支持 (TypeScript)

在各项目的 `tsconfig.json` 中保持 `paths` 映射，确保编辑器能正确跳转定义和提示类型：

```json
{
  "compilerOptions": {
    "paths": {
      "@meridian/logger": ["../../packages/logger/src/index.ts"]
    }
  }
}
```

## 总结

在 Cloudflare Workers 和 Nuxt 的 Monorepo 开发中，显式配置构建工具的 **Alias (别名)** 是解决本地包引用最直接有效的方法，它避免了每次修改共享包都需要重新 build 的繁琐流程。
